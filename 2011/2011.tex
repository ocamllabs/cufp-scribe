% This is file JFP2egui.tex
% release v1.02, 27th September 2001
%   (based on JFPguide.tex v1.11 for LaTeX 2.09)
% Copyright (C) 2001 Cambridge University Press

\NeedsTeXFormat{LaTeX2e}

\documentclass{jfp1}

%%% Macros for the guide only %%%
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\eg{\emph{e.g.}\ }
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt%
  \begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{$\longrightarrow\rlap{$#1$}$\hspace{1em}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}

\title[Commercial Users of Functional Programming 2011]{Commercial Users of Functional Programming}

\author[Anil Madhavapeddy]
       {Anil Madhavapeddy,\\
        Computer Laboratory,\\
        University of Cambridge,\\ 
        15 JJ Thomson Avenue, Cambridge CB3 0FD, UK\\
        \email{avsm2@cl.cam.ac.uk}}

\author[Yaron Minsky]
       {Yaron Minsky,\\
        Jane Street Capital,\\
        Somewhere in NYC,\\ 
        \email{yminsky@gmail.com}}

\author[Marius Eriksen]
       {Marius Eriksen,\\
        Twitter,\\
        Somewhere in SF,\\ 
        \email{marius@twitter.com}}


\jdate{September 2001, update April 2007}
\pubyear{2001}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\doi{S0956796801004857}

\newtheorem{lemma}{Lemma}[section]

\begin{document}

\label{firstpage}

\maketitle

\begin{abstract}
The scribe report from the Commercial Uses of Functional Programming 2011 workshop, held in association with ICFP in Tokyo, Japan.
\end{abstract}


\section{Overview}

location, num submissions, areas of interest. 

\subsection{Pragmatic Haskell}

Lennart Augustsson from Standard Charter opened the proceedings by relating his
commercial use of Haskell over the years. He authored the first Haskell
compiler, {\tt hbc}, which still remains competetive with the Glasgow Haskell
Compiler to this day.  Lennart subsequently developed several Haskell variants
that were tailored for
his needs.

First was {\tt pH} (find out more).

Lennart then designed the Bluespec hardware description language, which is a
full implementation of Haskell at compile-time, with Verilog output for
hardware synthesis. Bluespec significantly raised the level of abstraction when
designing hardware (e.g. with numbers and arithmetic in the types), and is
still available commercially today~\cite{bluespec}.

In the banking industry, most traders do not need the full power and complexity
of a programming language such as Haskell, and the result was the {\tt Mu}
dialect.

{\tt Mu} is a strict language with recursion disabled by default, and strings
instead of lists of characters.  It features SafeIO, which provides input but
no output by default, ensuring that code ``cannot launch missiles''. The {\tt
Mu} code works when embedded in Haskell, all data is serializable, compiler
transformations are done assuming that the code is terminating, and unused
computations are discarded at compile time.

Their codebase is of significant size, and lives within a library for quants
written in a combination of C++, Haskell and Mu, and can easily be invoked from
Excel, C\#, Java or any other component. Only 6\% of {\tt Mu} modules in their
codebase turn on recursion. Although Mu supports optional call-by-name, it is
only needed in around 20 places in their codebase.

Strictness is useful due to the ease of obtaining stack traces, tracking
resource usage, debugging and exception propagation, but makes it harder to
semantically compose modules together.  Lennart noted that Excel has a more
expressive effect system than Haskell and provides an effective front-end to
composing {\tt Mu} modules. He demonstrated coding Mu within Excel live on stage,
via an interactive and interpreted version.

The audience asked about integration between the Bluespec hardware description
language and Mu, since both require code that statically terminates. However,
Lennart replied that ``if you want to design hardware you need to have some
clue about what you are doing''.

\subsection{Simulation and Testing}

intro: reproducible and scalable testing is essential for the complex systems we use today. the submitted talks covered an interesting range of real-world systems, such as smart grid, future internet and automotive and aeronautical systems.

\subsubsection{Erlang: Large-Scale Discrete Event Simulation}

Olivier Boudeville from EDF moved us onto simulations. Many industry areas such
as the Smart Energy Grid~\cite{x} or Future Internet architectures require a
large-scale discrete event simulation system. They designed Sim Diasca in
Erlang to meet this need for scalability and reliability, with support for
upwards of 50 million parallel instances of complex models.

Sim Diasca has no fixed topology and uses Erlang actors for RPCs, with the main
role of the engine as a scheduler that enforces causality, reproducibility of
the model simulation, and some forms of ergodicity. They designed ``Wooper'' as
a library that maps object-oriented programming styles onto a distributed
functional style suitable for deployment on the Erlang base.

The use of Erlang and functional programming was ``massively positive'', as the
domain normally uses C++ and CORBA.  Erlang's support for distributed
computations and more suitable language constructs made complex algorithms
significantly easier to express.  On the downside, they did meet with some
resistance to using a relatively unknown language, and found developers harder
to hire than with more conventional languages.

\subsubsection{Erlang: Testing Safety Critical Automotive Components}

The next talk by Thomas Arts from TODO covered the huge area of testing
automotive components. The average modern car has over 64 computers that are
networked (``the brakes might need to know how fast the car is going!'').  The
computers are sourced from a variety of vendors, and so interoperability
testing is critical safety, as well as knowing who to blame in the event of a
software failure.

The industry standard for automotive components is AUTOSAR~\cite{x}. Initially,
AUTOSAR outsourced the testing and over thirty per-years were spent on writing
manual tests. The result was a disaster that was unsuitable for use. This is
because AUTOSAR is highly configurable, with thousands of standardised
parameters that are hard to express manually.

The solution came in the form of Erlang and QuickCheck, which resulted in an
order of magnitude less code and gave significantly more reliable coverage of
AUTOSAR configurations.  QuickCheck generates marshalling code to talk to the C
AUTOSAR libraries.

TODO Questions: do you test the models. Any idea of the state space you are
covering? Not sure what the answers were.

\subsection{Web and Mobile Development}

intro: functional programming on the web is making inroads into both client-side development, and scalable server stacks. here are 3 talks on it..

\subsubsection{OCaml: Mobile HTML5 Development}

We moved on from testing and simulation to the world of functional web
development in Japan. Keigo Imai delivered an entertaining talk about the
consultancy (IPTL) he works for, where 45\% of their annual sales are from
functional programming projects.

Their typical sales cycle begins with customers specifying their choice of
programming language, and impossibly tight deadlines. IPTL then propose using
their existing OCaml codebase to deliver the solution, but within the required
deadline and with much less risk. IPTL continually educate their customers
about the benefits of rapid development using functional languages.

Keigo demonstrated a foreign exchange chart application that works on iPhone
and Android, dynamically drawn using an HTML5 canvas. It was built using OCaml
and and compiled into Javascript using OCamlJS~\cite{x}. The static typing of
DOM elements avoided many runtime errors (particularly with the complex Canvas
tag), and the web SQL database API is wrapped in a monad and bound using a
continuation passing style. Inline Javascript is used where more low-level
control is required.

Performance has been fine with OCamlJS, and no bugs have been reported yet on
its output (to quote Keigo, "it is written in our miraculous super OCaml
technique!").

\subsubsection{Scala: Large Scale Internet Services at Twitter}

Twitter is a social network for sharing short text messages. It is growing in
popularity extremely fast, and some components have to serve in excess of
$10^6$ queries per second.

Steve Jensen and Wilhelm Bierbaum described how the entire backend
infrastructure is implemented using Scala.  The JVM is the preferred virtual
machine due to its maturity and performance, and Scala provides a much better
type system and functional programming features than code in Java directly.

All client requests go through a Scala proxy called TFE, which routes requests
via the Finagle distributed RPC system~\cite{f}. Request streams are passed
through filters that transform and apply processing functions on them.  Filters
can use existing Java libraries, which is very useful to interface with
existing libraries. 

The use of the JVM means that many existing debugging and profiling tools (e.g.
Yourkit, JStat, VisualVM) can be used, but the name mangling and anonymous
functions in Scala do introduce some incompatiblities.  The use of immutable
values result in a lot of pressure on the garbage collector, and they often
spend more time understanding and tuning the GC interactions with the program
than actually writing the code.

Twitter has also been hiring many programmers who never used Scala before.
While most of them understand the concepts underlying functional programming,
the syntax of Scala can often be suble, and the use of implicits are often
difficult for beginners.

\subsubsection{F\#: Mobile Applications using WebSharper}

Adam Granicz from Intellifactory began by pointed out that the market for
mobile applications is huge, growing to 3.7 billion users using smartphone in
the next year (XXX or 5 years?).  However, it requires a very heterogenous
programming style and choice of language, as every current platform differs
significantly (e.g. Android, iPhone, Windows Mobile).

Ideally, we need to program mobile applications using higher level
abstractions, support compilations to multiple targets, and make use of desktop
and cloud resources when available. The switch to proprietary and divergent 
APIs on different devices is a step backwards.

Javascript is becoming the intermediate language that connects these devices
together, and Windows 8 is even promoting it for building native desktop
applications. Intellifactory built the WebSharper programming framework in F\#
that outputs Javascript that works with all of these devices.

With WebSharper, all of the server and client code is written in F\#, and
compiles to a complete standalone web application. The F\# interfaces provide
type-safe URLs that helps prevent common errors, and ``sitelets'' and
``formlets'' that are composable abstractions for fragments of websites.

TODO Question: FRP?

\subsection{Embedded Systems}

FP is being used more in embedded systems, as the safety properties and type system helps generate safer and more compact code...

\subsection{Cryptol: Theorem-Based Derivation of an AES Implementation}

John Launchbury from Galois described their Cryptol declarative specification language
for cryptographic protocols~\cite{xxx}. Galois are now working on automatically
synthesising FPGAs from these specifications.

They implement a first-order functional language with size-type declarations,
and recursion is available via stream equations.  The only sequentialization
comes from data dependencies, making it possible to efficiently evaluate this
language on FPGAs. Cryptography is also a natural match for FPGAs, and Cryptol
makes it easier to experiment with several implementations. They use a
QuickCheck~\cite{x} testing tool to ensure that the Cryptol code is equivalent
to the reference specification, and Cryptol has a {\tt theorem} keyword to
express properties such as the equivalence between an encryption and decryption
operation.

\subsubsection{Haskell: A Real Time Programming Project in Real Time}

Gregory Wright from Alcatel-Lucent Bell Labs describes a project that used Haskell 
to build the core of a real-time communication system.  It was built by
the GreenTouch consortium, an organization of equipment
vendors, service providers, and research institutes to
show a new antenna technology that reduces the energy used
by wireless networks.  The goal of the project was to demonstrate
an algorithm that reduces radio transmit power as the number
of base station antenna elements is increased, and is capable of scaling
to antennas with thousands of elements.

An antenna can focus on a user and calibrate the amount of data sent ove the
link. As a result of this, the power used to go to an individual handset can be
adjusted with respect to a target rate.  This was initially simulated, and then
later run on real hardware as a soft realtime system.

In total, the project lasted 14 real days. As a result of the timescale, it
used very vanilla Haskell (e.g. arrays weren't unboxed), with no voodoo to
improve memory behaviour, or strictness annotations. The STM library was used,
as well as the DSP library from Hackage.

Despite this simplicity, the project was a big success. An important factor was that 
they always had a working system, with upgrades staged well. Haskell provided a high
degree of safety from ``crashing and burning''.

\subsection{Big Data}

distributed big data and functional programming seems a natural fit, but Java is dominant so far. these two talks introduce FP into this realm...

\subsubsection{Erlang/OCaml: Disco, a MapReduce Platform}

Prashanth Mundkur from Nokia Research in Palo Alto talked about the Disco Project.  When Nokia started evaluating systems for distributed data processing, the most popular solution was Hadoop~\cite{x}. However, this was a ``massive pile of Java software'' that was very complex to configure and operate, and an Erlang hacker at Nokia wondered how hard it would be to implement a simpler alternative.

The first Disco prototype took a few weeks, with Erlang being used to act as the coordination server, and Python to write the data processing scripts. OCaml has recently been added as a more strongly typed data processing alternative language.

Erlang provides quite a few useful tools that made Disco easier to implement. In particular, a remote shell to invoke RPC on hosts in the cluster and fprof to collect profiling information in real-time. The dynamic typing did result in some hard to find bugs, and the dialyzer static analysis tool is now used extensively on the Disco codebase (but is not mandatory).

\subsubsection{OCaml: The Acunu Storage Platform}

Tom Wilkie from Acunu in London then presented their Castle storage system to
optimise big data storage and processing.  It consists of a management stack
written in OCaml to handle the control requests (for snapshots, backups or
rollbacks), and a storage stack to implement a variety of algorithms for
compact persistent storage to disk.  Since their filesystem is under
development, the intention was to use OCaml to experiment with many different
techniques and rapidly iterate through ideas.

However, although OCaml was effective for implementing the core algorithm, they
spent a lot of time on the support code to serialise data to and from disk, and
deal with threading. When the filesystem codebase was moved to Java,
performance increased by 6x times. The audience suggested a few techniques to
speed up the OCaml code, such as the Lwt threading library and Bitstring syntax
extension, and increasing the number of I/O threads used. Tom acknowledged
these could help, but that their availability should be promoted and documented
better. 

\subsection{Gaming}

first gaming talk in CUFP, also mention Sweeney POPL talk as background.

\subsubsection{mzScheme: Functional DSLs for Game Development}

Dan Liebgold from Naughty Dog Software in Santa Monica then came on stage with
the first gaming related talk at CUFP. They produce the popular Uncharted game
series for the Playstation, which is famous for its complex and interactive
scripted scenes.  Dan described a modern game as a major production effort, where
artists produce data and programmers produce code.

Naughty Dog has a history of using various Lisp dialects to handle the code and
data in a unified way. But when making the jump from the Playstation 2 to the
Playstation 3, they decided that maintaining a custom Lisp-based game
development system was too costly, and instead dedicated their efforts to
rebuilding the tools, engine, and game in C++ and assembly language.

This decision left no scripting system for gameplay and, more importantly, no
system for creating DSLs and the oodles of “glue” data that is typically
required to develop a major video game. There was no off-the-shelf scripting
system that fit the stringent memory requirements in a Playstation 3, and no
language that would allow rapid DSL creation that fit into the existing tool
chain.

With a bit of naivety, a penchant for the Scheme language, and a passion for
functional programming techniques, the team dove in and put together a system
to fill in the gaps!  Dan reported that the results have been very good, but
not without many issues.  In particular, garbage collector performance sometime
led to manual tuning being required, and build environment integration was
tricky. Syntax transformations and error reporting led to confusion with new
programmers too. 

On the other hand, the functional nature of the system was a big win, as it
allowed them to flexibly distill game data down to just the right form to embed
into the resource-constrained run-time environment.  The final result is a
system where programmers, artists, animators, and designers are productively
``programming'' directly in an S-expression Scheme-like language.

\end{document}

% end of JFP2egui.tex
