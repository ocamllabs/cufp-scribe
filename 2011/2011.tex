% This is file JFP2egui.tex
% release v1.02, 27th September 2001
%   (based on JFPguide.tex v1.11 for LaTeX 2.09)
% Copyright (C) 2001 Cambridge University Press

\NeedsTeXFormat{LaTeX2e}

\documentclass{jfp1}

%%% Macros for the guide only %%%
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\eg{\emph{e.g.}\ }
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt%
  \begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{$\longrightarrow\rlap{$#1$}$\hspace{1em}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}

\title[Commercial Users of Functional Programming 2011]{Commercial Users of Functional Programming}

\author[Anil Madhavapeddy]
       {Anil Madhavapeddy,\\
        Computer Laboratory,\\
        University of Cambridge,\\ 
        15 JJ Thomson Avenue, Cambridge CB3 0FD, UK\\
        \email{avsm2@cl.cam.ac.uk}}

\author[Yaron Minsky]
       {Yaron Minsky,\\
        Jane Street Capital,\\
        Somewhere in NYC,\\ 
        \email{yminsky@gmail.com}}

\author[Marius Eriksen]
       {Marius Eriksen,\\
        Twitter,\\
        Somewhere in SF,\\ 
        \email{marius@twitter.com}}


\jdate{September 2001, update April 2007}
\pubyear{2001}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\doi{S0956796801004857}

\newtheorem{lemma}{Lemma}[section]

\begin{document}

\label{firstpage}

\maketitle

\begin{abstract}
The scribe report from the Commercial Uses of Functional Programming 2011 workshop, held in association with ICFP in Tokyo, Japan.
\end{abstract}


\section{Overview}

location, num submissions, areas of interest.

\subsection{Pragmatic Haskell}

Lennart Augustsson from Standard Charter opened the proceedings by relating his
commercial use of Haskell over the years. He authored the first Haskell
compiler, {\tt hbc}, which still remains competetive with the Glasgow Haskell
Compiler to this day.  Lennart subsequently developed several Haskell variants
that were tailored for
his needs.

First was {\tt pH} (find out more).

Lennart then designed the Bluespec hardware description language, which is a
full implementation of Haskell at compile-time, with Verilog output for
hardware synthesis. Bluespec significantly raised the level of abstraction when
designing hardware (e.g. with numbers and arithmetic in the types), and is
still available commercially today~\cite{bluespec}.

In the banking industry, most traders do not need the full power and complexity
of a programming language such as Haskell, and the result was the {\tt Mu}
dialect.

{\tt Mu} is a strict language with recursion disabled by default, and strings
instead of lists of characters.  It features SafeIO, which provides input but
no output by default, ensuring that code ``cannot launch missiles''. The {\tt
Mu} code works when embedded in Haskell, all data is serializable, compiler
transformations are done assuming that the code is terminating, and unused
computations are discarded at compile time.

Their codebase is of significant size, and lives within a library for quants
written in a combination of C++, Haskell and Mu, and can easily be invoked from
Excel, C\#, Java or any other component. Only 6\% of {\tt Mu} modules in their
codebase turn on recursion. Although Mu supports optional call-by-name, it is
only needed in around 20 places in their codebase.

Strictness is useful due to the ease of obtaining stack traces, tracking
resource usage, debugging and exception propagation, but makes it harder to
semantically compose modules together.  Lennart noted that Excel has a more
expressive effect system than Haskell and provides an effective front-end to
composing {\tt Mu} modules. He demonstrated coding Mu within Excel live on stage,
via an interactive and interpreted version.

The audience asked about integration between the Bluespec hardware description
language and Mu, since both require code that statically terminates. However, Lennart
replied that ``if you want to design hardware you need to have some clue about
what you are doing''.

\subsection{Theorem-Based Derivation of an AES Implementation}

John Launchbury from Galois continued with the theme of reliable hardware synthesis. Galois has developed the Cryptol declarative specification language for cryptographic protocols~\cite{xxx}, and are now working on automatically synthesising FPGAs from these specifications.

They implement a first-order functional language with size-type declarations, and recursion is available via stream equations.  The only sequentialization comes from data dependencies, making it possible to efficiently evaluate this language on FPGAs. Cryptography is also a natural match for FPGAs, and Cryptol makes it easier to experiment with several implementations. They use a QuickCheck~\cite{x} testing tool to ensure that the Cryptol code is equivalent to the reference specification, and Cryptol has a {\tt theorem} keyword to express properties such as the equivalence between an encryption and decryption operation.

\subsection{Discrete Event Simulation and Testing}

Olivier Boudeville from EDF moved us onto simulations. Many industry areas such as the Smart Energy Grid~\cite{x} or Future Internet architectures require a large-scale discrete event simulation system. They designed Sim Diasca in Erlang to meet this need for scalability and reliability, with support for upwards of 50 million parallel instances of complex models.

Sim Diasca has no fixed topology and uses Erlang actors for RPCs, with the main role of the engine as a scheduler that enforces causality, reproducibility of the model simulation, and some forms of ergodicity. They designed ``Wooper'' as a library that maps object-oriented programming styles onto a distributed functional style suitable for deployment on the Erlang base.

The use of Erlang and functional programming was ``massively positive'', as the domain normally uses C++ and CORBA.  Erlang's support for distributed computations and more suitable language constructs made complex algorithms significantly easier to express.  On the downside, they did meet with some resistance to using a relatively unknown language, and found developers harder to hire than with more conventional languages.


The next talk by Thomas Arts from TODO covered the huge area of testing automotive components. The average modern car has over 64 computers that are networked (``the brakes might need to know how fast the car is going!'').  The computers are sourced from a variety of vendors, and so interoperability testing is critical safety, as well as knowing who to blame in the event of a software failure.

The industry standard for automotive components is AUTOSAR~\cite{x}. Initially, AUTOSAR outsourced the testing and over thirty per-years were spent on writing manual tests. The result was a disaster that was unsuitable for use. This is because AUTOSAR is highly configurable, with thousands of standardised parameters that are hard to express manually.

The solution came in the form of Erlang and QuickCheck, which resulted in an order of magnitude less code and gave significantly more reliable coverage of AUTOSAR configurations.  QuickCheck generates marshalling code to talk to the C AUTOSAR libraries.



\end{document}

% end of JFP2egui.tex
