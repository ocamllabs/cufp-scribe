% This is file JFP2egui.tex
% release v1.02, 27th September 2001
%   (based on JFPguide.tex v1.11 for LaTeX 2.09)
% Copyright (C) 2001 Cambridge University Press

\NeedsTeXFormat{LaTeX2e}

\documentclass{jfp1}
\bibliographystyle{jfp}
\usepackage{url}

%%% Macros for the guide only %%%
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\eg{\emph{e.g.}\ }
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt%
  \begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{$\longrightarrow\rlap{$#1$}$\hspace{1em}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}

\title[Commercial Users of Functional Programming 2012]
      {Commercial Users of Functional Programming Workshop Report}

\author[Michael Sperber and Anil Madhavapeddy]
       {MICHAEL SPERBER\\
         Active Group GmbH, Hornbergstra\ss{}e 49\\
         70794 Filderstadt, Germany\\
         ANIL MADHAVAPEDDY\\
        Computer Laboratory, University of Cambridge\\ 
        15 JJ Thomson Avenue, Cambridge CB3 0FD, UK}

\jdate{May 2012}
\pubyear{2012}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}

\begin{document}

\label{firstpage}
\maketitle

\section{Overview}

Commercial Users of Functional Programming (CUFP) is a yearly workshop
that is aimed at the community of software developers who use functional
programming in real-world settings.  This scribe report covers the talks
that were delivered at the 2012 workshop, which was held in association
with ICFP in Copenhagen.  The goal of the report is to give the reader
a sense of what went on, rather than to reproduce the full details
of the talks.  Videos and slides from all the talks are available online at \url{http://cufp.org}.

\section{Keynote: Adopting Functional Programming}

Kresten Krab Thorup, CTO of Trifork, Aarhus gave the keynote address,
and took us on the voyage he had taken from being on ``object head''
to ``Erlang land.''  Thorup's foundational training in software
development was all in terms of object-oriented methodologies.  He
went on to work on Objective C for NeXT, afterwards took his Ph.D.\
and then founded Trifork, an IT services company with now about 250
employees that develops software solutions, provides training, and
organizes several well-respected conferences.

While Trifork originally capitalized almost exclusively on its Java
expertise, it now successfully applies Erlang in large-scale
industrial projects.  Thorup described (taking cues from anthropology)
how many organizations have not been able to make such transitions
easily: Groups tend to gather around an idea that keeps them together,
and try to keep new ideas at bay.  This makes it difficult for
long-time OO developers to adopt functional programming.

Trifork managed to stay flexible by making learning about new ideas
and communicating them part of their regular operation: Everyone at
Trifork should spend 10\% of their time in the structured exchange of
knowledge, by giving presentations, organizing meetings, give training
classes, or organizing conferences.

Thorup reviewed object-oriented programming and the ecosystem around
it to show how it had become successful: Through an intuitive idea~--
``an object is an independent encapsulated entity that inteprets
inputs on its own account''~-- but also because of the availability of
thinking tools: graphical notation for design, tools for mapping those
designs to programs, books on comon problems akin to ``Design
Patterns''~\cite{GammaHelmJohnsonVlissides1995}, analysis methods for producing systems,
and standardized qualification processes.

However, Thorup sees a series problem with the object-oriented model,
as objects have no coherent model of time, and no good way to compose
behaviors over time.  With the rise of multicore and distributed
computing, these become increasingly important.  Erlang, supporting
functional programming and an actor model for concurrency, parallelism
and distribution, addresses this issue.  Thorup stressed that Erlang
is not primarily a functional programming language, but that
functional programming helps Erlang meet its requirements: being a
language for writing robust distributed applications.

Thorup described large-scale projects done using Erlang: One for
managing health-care records in Denmark, and one for sharing data
among ``sometimes connected devices'' such as a cell phones at a music
festival.

Thorup concluded by noting that two fundamental classes of problems in
software development require different classses of solutions:
\textit{Interactive systems} with multiple parties are fundamentally
stateful, and where developers should understand the handling of
state~-- for those problems, actors are a good model.
\textit{Transformational systems} map input to output, where
developers want to abstract over the details of hardware utilization,
the handling of mutable state and coordination.

\section{Jane Street Status Report}

Jane Street is a quantitative proprietary trading firm that has been a
well-known user and supporter of OCaml.  Yaron Minsky reviewed the
past decade of OCaml use at Jane Street.

Jane Street has three kinds of requirements on their own software:
\begin{description}
\item[Correctness] Jane Street trades billions of dollars every day~--
  much more than the company is worth.  Hence, a software error can
  have disastrous consequences.
\item[Agility] Jane Street needs to be able to adapt the software
  quickly to exploit new market opportunities as they are found.
\item[Performance] The software needs to quickly to exploit market
  opportunities.
\end{description}
%
Jane Street has written OCaml code for a number of application areas:
research tools for investiagting trading strategies, trading systems
(replacing legay systems written in VBA/Excel) that make trades
automatically, order gateways that implement protocols to interact
with markets, post-trade software to analyze and clean up completed
trades, systems infrastructure to manage systems, development tools,
trading tools, tools for managing market-data and desk infrastructure.

Minsky could not remember a crucial error in the software that
happened in production: Code at Jane Street generally fails by turning
off the system, which is acceptable in this environment.  Jane
Street's user interfaces are all text-based, and written using
Curses~-- this ``prevents bad UX designers from doing UX.''

Another important that favors OCaml is how the type system eases large
refactoring projects: The type system catches most mistakes that occur
in the middle of such projects.  The type system helps programmers
write readable, explicit code, which is more important than great
productivity increases or extremely concise programs.

Jane Street has developed a number of generally useful libraries for
OCaml, many of which are open
source.\footnote{http://janestreet.github.io/} In particular,
\textit{Core} is an enhanced ``standard library,'' meant to the
minimalistic libraries that ship with OCaml.  \textit{Async} is a
library with monadic concurrency abstractions, similar to available in
other functional languages such as
F\#~\cite{Syme:2011:FAP:1946313.1946334}.  \textit{Incremental}
describes large-scale computations with small updates.
\textit{Catalog} is a publish/subscribe system.  \textit{Nile} is a
distributed message-passing library.

In summary, Jane Street is fully committed to OCaml, and will continue
to do its development in OCaml.  Jane Street will continue to
contribute to open-source projects, and to collaborate with others
working on or in OCaml.

\section{Transmitting customised ads to set-top boxes with Erlang}

Macías Lopez, David Cabrero and Laura M.\ Castro from the University
of A Coruña reported on \textit{ADVERTISE}
project~\cite{Lopez:2012:DDA:2370776.2370800,
  Lopez:2012:FTC:2364489.2364498}.  \textit{ADVERTISE} is a
distributed system for transmission of customised ads to TV set-top
boxes via the TV network of a cable provider.  The system~-- entirely
written in Erlang~-- compiles events, emits ``advertising signals'' to
set-top boxes, and collects statistics about how many times specific
ads were displayed on consumer boxes.  ADVERTISE sends ads to more
than 100,000 clients.

Lopez reported on the difficulties of developing and deploying such a
large-scale system.  In particular, after the original system
implementation, the customer only provided hardware that did not
satisfy the original minimum specifications.  Moreover, the network
exhibits frequent node failures and netsplits, which disrupted the
operation of the original system.  Thus, while Erlang was a good
choice for implementing the system, merely using Erlang does not make
a distributed system robust in highly unreliable environments.
ADVERTISE yielded insights into best practices for implementing
distributed systems in such environments.

Netsplits in particular are problematic, as nodes may incorrectly
conclude other nodes are down, and then compete for control of the
network.  This may lead to data inconsistencies and duplicate
implementations of responsibilities assumed to be unique. An ADVERTISE
node, when it loses network connectivity, immediately suspends
execution and waits until it is restored, choosing consistency over
availability in such scenarios to avoid corrupting advertising
campaigns.

\section{Haskell for XenClient}

Matthias Görgens reported on using Haskell in the XenClient project at
Citrix: XenClient is a virtual-machine manager for clients, primarily
laptops in corporate and government environments, where XenClient
offers functionality different from the long-established XenServer,
such as trusted-computing support with hard-drive encryption and
native graphics performance.

The XenClient management stack consists of many daemons that commicate
via D-Bus and V4V (a VM-to-VM communications protocol).  Originally,
many of the daemons were written using Ruby, but a rising bug count
motivated the development team to look for alternatives, particularly
statically-typed languages to catch more bugs at development time.
Some daemons were then rewritten in Haskell.  By now, there are about
25,000 loc in Haskell in the system.  The XenClient daemons are
typically long-running, perform short bursts of communication and
computation upon a request discovered via polling, do not hold much
state and are restartable: Haskell is well-suited for this kind of
application.

As XenServer already uses OCaml for its management toolstack, it is a
bit surprising that XenClient chose Haskell: Görgens cited personal
preferences, the availability of more libraries, and the fact that
Haskell ``relieves pressure to share code with XenServer.''

Görgens also cited a few problems with using Haskell: XenClient found
it difficult to handle IO-heavy workloads, making Haskell work with
the OpenEmbedded build system in use in XenClient, and the
successfully train developers not yet familiar with functional
programming.

\section{Functional Programming @ Ghent IT Valley}

% Slides here:
% http://www.slideshare.net/toolslive/cufp-2012-talk

\section{From Streams to Functions (and Back Again)}

\section{Functional Big-Data Genomics}

\section{Using F\# to Prove Stabilization of Biological Networks}

\section{Developing an F\# Bioinformatics Application with HTML5
  Visualization}

\section{Developing Medical Software in Scala and Haskell}

\section{Functional programs connected to the power grid}

\section{Clojure iPad analytics dashboard in energy sector}

\section{The Awesome Haskell FPGA Compiler}

\section{Conclusion}

We would like to thank Simon Thompson and Duncan Coutts for helping to
organize the CUFP tutorials, and Ashish Agarwal for organizing the BoF
sessions.  We thank Kresten Krab Thorup and Yaron Minsky for providing
notes on their talks.  Also, we thank Peter Thiemann and Fritz Henglein and the
whole ICFP/CUFP team for their assistance in Copenhagen.  We look
forward to CUFP 2013 in Boston!

\bibliography{biblio}
\end{document}

% end of JFP2egui.tex
